### 多表查询

#### 基础数据

```sql
create table dept(
	id int primary key auto_increment,
	name varchar(20)
);
insert into dept(name) values('研发部'),('市场部'),('财务部');

create table emp(
	id int primary key auto_increment,
	name varchar(10),
	gender char(1), -- 性别
	salary double, -- 工资
	join_date date, -- 入职日期
	dept_id INT,
	foreign key (dept_id) references dept(id) -- 外键，关联部门表的主键
);

insert into emp(name, gender,salary, join_date,dept_id) values('张三','男', 12000, '2020-01-01',1);
insert into emp(name, gender,salary, join_date,dept_id) values('李四','男', 22000, '2019-03-01',2);
insert into emp(name, gender,salary, join_date,dept_id) values('王五','女', 3200, '2025-02-01',3);
insert into emp(name, gender,salary, join_date,dept_id) values('哈哈','女', 1000, '2000-12-01',1);
```

#### 内连接查询

##### 隐式内连接

使用where条件消除无用信息

例如：查询所有员工信息和对应的部门信息

```mysql
select * from emp,dept where emp.dept_id=dept.id
```

例如：查询员工表的名称，性别，部门表的名称

```mysql
select emp.name, gender,dept.name from emp,dept where emp.dept_id= dept.id;

select
	t1.name,t1.gender,t2.name
from 
	emp t1, dept t2
where
	t1.dept_id=t2.id;
```

##### 显式内连接

语法： select 字段列表 from 表名 inner join 表名2 on 条件

inner 关键字可以省略

```mysql
select * from emp inner join dept on emp.dept_id = dept.id;
```

#### 外连接查询

##### 左外连接

语法：select 字段列表 from 表1 left outer join 表2 on 条件

outer 关键字可以省略

```mysql
select
	t1.*,t2.name
from
	emp t1
left join
	dept t2
on
	t1.dept_id=t2.id;
```

总结过可以看出其实左外连接查询的是左表所有数据以及其他交集部分

LEFT JOIN 关键字会从左表那里返回所有的行，即使在右表中没有匹配的行。

##### 右外连接

语法：select 字段列表 from 表1 right outer join 表2 on 条件

outer 关键字可以省略

其实右外连接查询的是右表所有数据以及其他交集部分

```mysql
select
	t1.*,t2.name
from
	emp t1
right join
	dept t2
on
	t1.dept_id=t2.id;
```

#### 子查询

概念： 查询中嵌套查询，称为子查询.

```mysql
select * from emp where salary=(select max(salary) from emp);
```

子查询包含几种不同的情况：

- 子查询的结果是单行单列
- 子查询的结果是多行单列的
- 子查询的结果是多行多列的

##### 子查询的结果是单行单列  Scalary subquery

子查询可以作为条件，使用运算符去判断。 运算符： **> , >= , <=, =**

```mysql
-- 查询员工工资小于平均工资的人
select * from emp where emp.salary < (select avg(salary) from emp);

/* Question: Find the employees who's salary is more than the average salary earned by all employees */
select *	-- outer query / main query
from emp
where salary > (select avg(salary) from emp); -- subquery / inner query

-- 用join方式
select *
from emp
join (select avg(salary) sal from emp) avg_sal
on emp.salary > avg_sal.sal;
```

##### 子查询的结果是多行单列

子查询可以作为条件，使用运算符**in**来判断

```mysql
-- 查询财务部和市场部所有员工的信息
select * from emp where dept_id in (select id from dept where name='财务部' or name='市场部');

/* Question: Find department who do not have any employees */
select * from dept
where dept.id not in (select distinct dept_id from emp);
```

##### 子查询的结果是多行多列的

```mysql
-- 查询入职日期在2019-01-01 之后的员工信息和部门信息
select * from dept t1, (select * from emp where emp.join_date>'2019-01-01') t2 where t1.id = t2.id;
--  通过内连接也可以;
select * from dept t1, emp t2 where t2.join_date>'2019-01-01' and t1.id=t2.id;

/* Question: Find the employees who earn the highest salary in each department */
-- 1. get the highest salary in each department
select dept_id, max(salary) from emp group by dept_id;
-- 2. find the employees who earn the highest salary
select * from emp
where (dept_id, salary) in (select dept_id, max(salary) from emp group by dept_id);
```

##### 关联子查询

```mysql
-- Correlated subquery
-- A subquery which is related to the outer query

/* Question: Find the employees in each department who earn more than the average salary in that department */
select * from emp e1
where salary > (select avg(salary)
                from emp e2
                where e2.dept_id =e1.dept_id);
                
/* Question: Find department who do not have any employees */
select * from dept d
where not exists (select 1 from emp e where e.dept_id = d.id);
```

#### 多表查询练习

基础数据

```mysql
-- 部门表
CREATE TABLE dept (
  id INT PRIMARY KEY PRIMARY KEY, -- 部门id
  dname VARCHAR(50), -- 部门名称
  loc VARCHAR(50) -- 部门所在地
);

-- 添加4个部门
INSERT INTO dept(id,dname,loc) VALUES 
(10,'教研部','北京'),
(20,'学工部','上海'),
(30,'销售部','广州'),
(40,'财务部','深圳');



-- 职务表，职务名称，职务描述
CREATE TABLE job (
  id INT PRIMARY KEY,
  jname VARCHAR(20),
  description VARCHAR(50)
);

-- 添加4个职务
INSERT INTO job (id, jname, description) VALUES
(1, '董事长', '管理整个公司，接单'),
(2, '经理', '管理部门员工'),
(3, '销售员', '向客人推销产品'),
(4, '文员', '使用办公软件');



-- 员工表
CREATE TABLE emp (
  id INT PRIMARY KEY, -- 员工id
  ename VARCHAR(50), -- 员工姓名
  job_id INT, -- 职务id
  mgr INT , -- 上级领导
  joindate DATE, -- 入职日期
  salary DECIMAL(7,2), -- 工资
  bonus DECIMAL(7,2), -- 奖金
  dept_id INT, -- 所在部门编号
  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),
  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)
);

-- 添加员工
INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES 
(1001,'孙悟空',4,1004,'2000-12-17','8000.00',NULL,20),
(1002,'卢俊义',3,1006,'2001-02-20','16000.00','3000.00',30),
(1003,'林冲',3,1006,'2001-02-22','12500.00','5000.00',30),
(1004,'唐僧',2,1009,'2001-04-02','29750.00',NULL,20),
(1005,'李逵',4,1006,'2001-09-28','12500.00','14000.00',30),
(1006,'宋江',2,1009,'2001-05-01','28500.00',NULL,30),
(1007,'刘备',2,1009,'2001-09-01','24500.00',NULL,10),
(1008,'猪八戒',4,1004,'2007-04-19','30000.00',NULL,20),
(1009,'罗贯中',1,NULL,'2001-11-17','50000.00',NULL,10),
(1010,'吴用',3,1006,'2001-09-08','15000.00','0.00',30),
(1011,'沙僧',4,1004,'2007-05-23','11000.00',NULL,20),
(1012,'李逵',4,1006,'2001-12-03','9500.00',NULL,30),
(1013,'小白龙',4,1004,'2001-12-03','30000.00',NULL,20),
(1014,'关羽',4,1007,'2002-01-23','13000.00',NULL,10);



-- 工资等级表
CREATE TABLE salarygrade (
  grade INT PRIMARY KEY,   -- 级别
  losalary INT,  -- 最低工资
  hisalary INT -- 最高工资
);

-- 添加5个工资等级
INSERT INTO salarygrade(grade,losalary,hisalary) VALUES 
(1,7000,12000),
(2,12010,14000),
(3,14010,20000),
(4,20010,30000),
(5,30010,99990);
```

- 查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述

  ```mysql
  -- 查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述
  select t1.id,t1.ename,t1.salary,t2.jname,t2.description from emp t1, job t2 where t1.job_id = t2.id;
  ```

- 查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置

  ```mysql
  -- 查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置
  select t1.id,t1.ename,t1.salary,t2.jname,t2.description,t3.dname,t3.loc from emp t1, job t2, dept t3  where t1.job_id = t2.id and t1.dept_id=t3.id;
  ```

- 查询员工姓名，工资，工资等级

  ```mysql
  -- 查询员工姓名，工资，工资等级
  select t1.ename, t1.salary, (select grade from salarygrade where  t1.salary> losalary and salary<hisalary)  grade from emp t1
  ```

  或者

  ```mysql
  select t1.ename,t1.salary,t2.grade from emp t1, salarygrade t2 where t1.salary > t2.losalary and t1.salary < t2.hisalary;
  ```

- 查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级

  ```mysql
  -- 查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级
  select
         t1.id,t1.ename,t1.salary,t2.jname,t2.description,t3.dname,t3.loc ,t4.grade
  from emp t1, job t2, dept t3, salarygrade t4
  where
        t1.job_id = t2.id
    and
        t1.dept_id=t3.id
  and (t1.salary > t4.losalary and t1.salary < t4.hisalary);
  ```

- 查询出部门编号、部门名称、部门位置、部门人数

  ```mysql
  -- 查询出部门编号、部门名称、部门位置、部门人数
  select t1.dname, t1.loc, (select count(id)  from emp where emp.dept_id=t1.id ) count from dept t1;
  ```

  ```mysql
  select t1.id, t1.dname,t1.loc, t2.total from dept t1, (select dept_id,count(id) total from emp group by dept_id) t2 where t1.id = t2.dept_id
  ```

- 查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询

  ```mysql
  -- 查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询
  select t1.ename, (select ename from emp where t1.mgr=id) from emp t1;
  ```

  ```mysql
  select
         t1.ename,
         t1.mgr,
         t2.id,
         t2.ename
  from emp t1
  left join  emp t2
  on t1.mgr = t2.id
  ```