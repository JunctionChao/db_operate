### 事务

[官方文档链接](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)

MySQL 事务主要用于处理操作量大，复杂度高的数据。

概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。

操作：

1. 开启事务：start transaction 或者 begin
2. 回滚：rollback
3. 提交：commit

注意：

mysql数据库，当且仅当引擎是InnoDB，才支持事务

mysql数据库中事务默认自动提交

一条DML（增删改）语句会自动提交奥一次事务

事务提交的两种方式：

自动提交：mysql的默认方式

手动提交：需要先开启事务，再提交

查看事务的默认提交方式：

```mysql
select @@autocommit; -- 1 表示自动提交，0表示手动提交

mysql> select @@autocommit;
+--------------+
| @@autocommit |
+--------------+
|            1 |
+--------------+
1 row in set (0.10 sec)
```

如果想要更改：

```mysql
set @@autocommit = 0;
```

#### 事务的四大特征

- 原子性：是不可分割的最小单位，要么同时成功，要么同时失败
- 持久性：当事务提交或回滚后，数据会持久化的保存数据
- 隔离性： 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）
- 一致性： 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。

#### 事务的隔离级别

概念：多个事务之间是相互隔离的，相互独立。但是多个事务操作同一批数据，会引发一些问题。设置不同的隔离级别就卡一解决这些问题

存在的问题：

- 脏读：一个事务，读取到另外一个事务中没有提交的数据
- 不可重复读（虚读）：在同一个事务中，两次读取到的数据不一样
- 幻读：一个事务操作数据表中所有记录，另外一个事务添加了一条数据，则第一个事务查询不到自己的修改

隔离级别：

- read umcommitted:读未提交。 会产生的问题：脏读，不可重复读，幻读

  A事务已执行，但未提交；B事务查询到A事务的更新后数据；A事务回滚；---出现脏数据

- read commit:读已提交。会产生的问题：不可重复读，幻读

  A事务执行更新；B事务查询；A事务又执行更新；B事务再次查询时，前后两次数据不一致；---不可重复读

- repeatable read: 可重复读。 可能会产生幻读 （mysql默认级别）

  A事务无论执行多少次，只要不提交，B事务查询值都不变；B事务仅查询B事务开始时那一瞬间的数据快照；

- serializable: 串行化。 可以解决所有的问题

  不允许读写并发操作，写执行时，读必须等待；

注意：隔离级别从小到大安全性越来越高，但是效率越来越低

数据库查询隔离级别：

```mysql
select @@transaction_isolation;  -- mysql8.0版本，不同版本命令可能有区别

mysql> select @@transaction_isolation; -- mysql默认为 REPEATABLE-READ
+-------------------------+
| @@transaction_isolation |
+-------------------------+
| REPEATABLE-READ         |
+-------------------------+
1 row in set (0.00 sec)
```

设置事务隔离级别：

```mysql
-- 设置mysql的隔离级别：
set session transaction isolation level 设置事务隔离级别

-- 设置read uncommitted级别：
set session transaction isolation level read uncommitted;

-- 设置read committed级别：
set session transaction isolation level read committed;

-- 设置repeatable read级别：
set session transaction isolation level repeatable read;

-- 设置serializable级别：
set session transaction isolation level serializable;
```

#### **事务四种隔离级别详解及示例**

SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

**Read Uncommitted（读取未提交内容）**

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

**Read Committed（读取提交内容）**

这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

**Repeatable Read（可重读）**

这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

**Serializable（可串行化）**

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。



**出现问题**

这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：

脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。

不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。



##### 测试示例

测试数据库为company，表为customers4；表结构：

```sql
mysql> desc customers4;
+--------------+-----------+------+-----+---------+-------+
| Field        | Type      | Null | Key | Default | Extra |
+--------------+-----------+------+-----+---------+-------+
| cust_id      | int(11)   | NO   |     | 0       |       |
| cust_name    | char(50)  | NO   |     | NULL    |       |
| cust_address | char(50)  | YES  |     | NULL    |       |
| cust_city    | char(50)  | YES  |     | NULL    |       |
| cust_state   | char(5)   | YES  |     | NULL    |       |
| cust_zip     | char(10)  | YES  |     | NULL    |       |
| cust_country | char(50)  | YES  |     | NULL    |       |
| cust_contact | char(50)  | YES  |     | NULL    |       |
| cust_email   | char(255) | YES  |     | NULL    |       |
+--------------+-----------+------+-----+---------+-------+
9 rows in set (0.00 sec)
```

- **将A的隔离级别设置为read uncommitted(未提交读)**

  `set session transaction isolation level read uncommitted;`

  查看隔离级别是否设置成功

  `select @@transaction_isolation` （mysql版本 8.0 以后）

  `select @@tx_isolation` （mysql版本 8.0 之前）

  查看mysql版本详情：  mysql\> status

  **A：**启动事务，此时数据为初始状态

   start transaction;

  **B：**启动事务，更新数据，但不提交

   start transaction;

  **A：**再次读取数据，发现数据已经被修改了，这就是所谓的“脏读”

  A客户端：

  ```mysql
  mysql> use company;
  Reading table information for completion of table and column names
  You can turn off this feature to get a quicker startup with -A
  
  Database changed
  mysql> select @@transaction_isolation;
  +-------------------------+
  | @@transaction_isolation |
  +-------------------------+
  | REPEATABLE-READ         |
  +-------------------------+
  1 row in set (0.00 sec)
  
  mysql> set session transaction isolation level read uncommitted;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> select @@transaction_isolation;
  +-------------------------+
  | @@transaction_isolation |
  +-------------------------+
  | READ-UNCOMMITTED        |
  +-------------------------+
  1 row in set (0.00 sec)
  
  mysql> start transaction;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> select * from customers4;
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  | cust_id | cust_name  | cust_address          | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  |       1 | spider_man | 中国深圳龙岗区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL       |
  |       2 | big        | 中国深圳南山区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL       |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  2 rows in set (0.00 sec)
  
  mysql> select * from customers4;
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  | cust_id | cust_name  | cust_address          | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  |       1 | spider_man | 中国深圳龙岗区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL       |
  |       2 | woman      | 中国深圳南山区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL       |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  2 rows in set (0.00 sec)
  ```

  B客户端：

  ```mysql
  mysql> use company;
  Reading table information for completion of table and column names
  You can turn off this feature to get a quicker startup with -A
  
  Database changed
  mysql> select * from customers4;
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  | cust_id | cust_name  | cust_address          | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  |       1 | spider_man | 中国深圳龙岗区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL       |
  |       2 | big        | 中国深圳南山区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL       |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  2 rows in set (0.00 sec)
  
  mysql> show create table customers4;
  +------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | Table      | Create Table                                                                              
  +------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | customers4 | CREATE TABLE `customers4` (
    `cust_id` int(11) NOT NULL DEFAULT '0',
    `cust_name` char(50) CHARACTER SET utf8 NOT NULL,
    `cust_address` char(50) CHARACTER SET utf8 DEFAULT NULL,
    `cust_city` char(50) CHARACTER SET utf8 DEFAULT NULL,
    `cust_state` char(5) CHARACTER SET utf8 DEFAULT NULL,
    `cust_zip` char(10) CHARACTER SET utf8 DEFAULT NULL,
    `cust_country` char(50) CHARACTER SET utf8 DEFAULT NULL,
    `cust_contact` char(50) CHARACTER SET utf8 DEFAULT NULL,
    `cust_email` char(255) CHARACTER SET utf8 DEFAULT NULL
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci |
  +------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  1 row in set (0.00 sec)
  
  mysql> start transaction;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> select * from customers4;
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  | cust_id | cust_name  | cust_address          | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  |       1 | spider_man | 中国深圳龙岗区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL       |
  |       2 | big        | 中国深圳南山区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL       |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  2 rows in set (0.00 sec)
  
  mysql> update customers4 set cust_name='woman' where cust_id=2;
  Query OK, 1 row affected (0.04 sec)
  Rows matched: 1  Changed: 1  Warnings: 0
  ```

  这时B客户端rollback：

  ```sql
  mysql> rollback;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> select * from customers4;
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  | cust_id | cust_name  | cust_address          | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  |       1 | spider_man | 中国深圳龙岗区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL       |
  |       2 | big        | 中国深圳南山区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL       |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  2 rows in set (0.00 sec)
  ```

  A客户端查看结果也变了，那么之前读取的数据就是 ‘脏读’

  ```mysql
  mysql> select * from customers4;
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  | cust_id | cust_name  | cust_address          | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  |       1 | spider_man | 中国深圳龙岗区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL       |
  |       2 | big        | 中国深圳南山区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL       |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  2 rows in set (0.00 sec)
  ```

  经过上面的实验可以得出结论，事务B更新了一条记录，但是没有提交，此时事务A可以查询出未提交记录。造成脏读现象。未提交读是最低的隔离级别。

- **将客户端A的事务隔离级别设置为read committed(已提交读)**

  `set session transaction isolation level read committed;`

  **A：**启动事务，此时数据为初始状态

  **B：**启动事务，更新数据，但不提交

  **A：**再次读数据，发现数据未被修改

  **B：**提交事务

  **A：**再次读取数据，发现数据已发生变化，说明B提交的修改被事务中的A读到了，这就是所谓的“不可重复读”

  A客户端：

  ```
  mysql> set session transaction isolation level read committed;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> select @@transaction_isolation;
  +-------------------------+
  | @@transaction_isolation |
  +-------------------------+
  | READ-COMMITTED          |
  +-------------------------+
  1 row in set (0.00 sec)
  
  mysql> commit;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> start transaction;
  Query OK, 0 rows affected (0.01 sec)
  
  mysql> select @@transaction_isolation;
  +-------------------------+
  | @@transaction_isolation |
  +-------------------------+
  | READ-COMMITTED          |
  +-------------------------+
  1 row in set (0.00 sec)
  
  mysql> select * from customers4;
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  | cust_id | cust_name  | cust_address          | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  |       1 | spider_man | 中国深圳龙岗区        | 深圳      | NULL       | NULL     | NULL         | NULL         |            |
  |       2 | big        | 中国深圳南山区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL       |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+------------+
  2 rows in set (0.00 sec)
  ```

  B客户端，这时update后还未commit，A客户端在事务中查到的还是旧数据

  ```
  
  Query OK, 0 rows affected (0.09 sec)mysql> start transaction;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> update customers4 set cust_email='AAA@szkingdom.com' where cust_name='spider_man';
  Query OK, 1 row affected (0.07 sec)
  Rows matched: 1  Changed: 1  Warnings: 0
  
  mysql> commit;
  Query OK, 0 rows affected (0.09 sec)
  ```

  B客户端commit后，再在A客户端查看：

  ```sql
  mysql> select * from customers4;
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  | cust_id | cust_name  | cust_address          | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email        |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  |       1 | spider_man | 中国深圳龙岗区        | 深圳      | NULL       | NULL     | NULL         | NULL         | AAA@szkingdom.com |
  |       2 | big        | 中国深圳南山区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL              |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  2 rows in set (0.00 sec)
  ```

  经过上面的实验可以得出结论，已提交读隔离级别解决了脏读的问题，但是出现了不可重复读的问题，即事务A在两次查询的数据不一致，因为在两次查询之间事务B更新了一条数据。已提交读只允许读取已提交的记录，但不要求可重复读。

- **将A的隔离级别设置为repeatable read(可重复读)**

  **A：**启动事务，此时数据为初始状态

  **B**：启动事务，更新数据，但不提交

  **A：**再次读取数据，发现数据未被修改

  **B：**提交事务

  **A：**再次读取数据，发现数据依然未发生变化，这说明这次可以重复读了

  **B：**插入一条新的数据，并提交

  **A：**再次读取数据，发现数据依然未发生变化，虽然可以重复读了，但是却发现读的不是最新数据，这就是所谓的“幻读”

  **A**：提交本次事务，再次读取数据，发现读取正常了

  A客户端：

  ```
  mysql> select @@transaction_isolation;
  +-------------------------+
  | @@transaction_isolation |
  +-------------------------+
  | READ-COMMITTED          |
  +-------------------------+
  1 row in set (0.00 sec)
  
  mysql> set session transaction isolation level repeatable read;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> select @@transaction_isolation;
  +-------------------------+
  | @@transaction_isolation |
  +-------------------------+
  | REPEATABLE-READ         |
  +-------------------------+
  1 row in set (0.00 sec)
  
  mysql> start transaction;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> select * from customers4;
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  | cust_id | cust_name  | cust_address          | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email        |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  |       1 | spider_man | 中国深圳龙岗区        | 深圳      | NULL       | NULL     | NULL         | NULL         | AAA@szkingdom.com |
  |       2 | big        | 中国深圳南山区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL              |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  2 rows in set (0.00 sec)
  ```

  B客户端：

  ```
  mysql> select * from customers4;
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  | cust_id | cust_name  | cust_address          | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email        |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  |       1 | spider_man | 中国深圳龙岗区        | 深圳      | NULL       | NULL     | NULL         | NULL         | AAA@szkingdom.com |
  |       2 | big        | 中国深圳南山区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL              |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  2 rows in set (0.00 sec)
  
  mysql> start transaction;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> update customers4 set cust_contact='13545467358' where cust_id=1;
  Query OK, 1 row affected (0.05 sec)
  Rows matched: 1  Changed: 1  Warnings: 0
  ```

  B客户端提交后：

  ```
  mysql> update customers4 set cust_contact='13545467358' where cust_id=1;
  Query OK, 1 row affected (0.05 sec)
  Rows matched: 1  Changed: 1  Warnings: 0
  
  mysql> commit;
  Query OK, 0 rows affected (0.09 sec)
  
  mysql> select * from customers4;
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  | cust_id | cust_name  | cust_address          | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email        |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  |       1 | spider_man | 中国深圳龙岗区        | 深圳      | NULL       | NULL     | NULL         | 13545467358  | AAA@szkingdom.com |
  |       2 | big        | 中国深圳南山区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL              |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  2 rows in set (0.00 sec)
  ```

  A客户端查询还是没变，退出事务后才变：

  ```
  mysql> select * from customers4;
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  | cust_id | cust_name  | cust_address          | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email        |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  |       1 | spider_man | 中国深圳龙岗区        | 深圳      | NULL       | NULL     | NULL         | NULL         | AAA@szkingdom.com |
  |       2 | big        | 中国深圳南山区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL              |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  2 rows in set (0.00 sec)
  
  mysql> commit;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> select * from customers4;
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  | cust_id | cust_name  | cust_address          | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email        |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  |       1 | spider_man | 中国深圳龙岗区        | 深圳      | NULL       | NULL     | NULL         | 13545467358  | AAA@szkingdom.com |
  |       2 | big        | 中国深圳南山区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL              |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  2 rows in set (0.00 sec)
  ```

  由以上的实验可以得出结论，可重复读隔离级别只允许读取已提交记录，而且在一个事务两次读取一个记录期间，其他事务部的更新不会影响该事务对记录的读取。但该事务不要求与其他事务可串行化。例如，当一个事务可以找到由一个已提交事务更新的记录，但是可能产生幻读问题(注意是可能，因为数据库对隔离级别的实现有所差别)。像以上的实验，就没有出现数据幻读的问题

- **将A的隔离级别设置为可串行化(Serializable)**

  **A：**启动事务，此时数据为初始状态

  **B：**发现B此时进入了等待状态，原因是因为A的事务尚未提交，只能等待（此时，B可能会发生等待超时）

  **A：**提交事务

  **B：**发现插入成功

  **A客户端：**

  ```sql
  mysql> set session transaction isolation level serializable;
  Query OK, 0 rows affected (0.28 sec)
  
  mysql> start transaction;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> select * from customers4;
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  | cust_id | cust_name  | cust_address          | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email        |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  |       1 | spider_man | 中国深圳龙岗区        | 深圳      | NULL       | NULL     | NULL         | 13545467358  | AAA@szkingdom.com |
  |       2 | big        | 中国深圳南山区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL              |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  2 rows in set (0.00 sec)
  ```

  B客户端：

  ```
  mysql> start transaction;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> select * from customers4;
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  | cust_id | cust_name  | cust_address          | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email        |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  |       1 | spider_man | 中国深圳龙岗区        | 深圳      | NULL       | NULL     | NULL         | 13545467358  | AAA@szkingdom.com |
  |       2 | big        | 中国深圳南山区        | 深圳      | NULL       | NULL     | NULL         | NULL         | NULL              |
  +---------+------------+-----------------------+-----------+------------+----------+--------------+--------------+-------------------+
  2 rows in set (0.00 sec)
  ```

  A客户端，update未提交：

  ```
  mysql> update customers4 set cust_country='China' where cust_id=1;
  Query OK, 1 row affected (0.05 sec)
  Rows matched: 1  Changed: 1  Warnings: 0
  ```

  B客户端，先进入等待，最后超时：

  ```sql
  mysql> update customers4 set cust_country='China' where cust_id=1;
  Query OK, 1 row affected (0.05 sec)
  Rows matched: 1  Changed: 1  Warnings: 0
  
  mysql> CERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
  ```

  在超时时间内，当A commit，B紧跟着update成功。

  serializable完全锁定字段，若一个事务来查询同一份数据就必须等待，直到前一个事务完成并解除锁定为止。是完整的隔离级别，会锁定对应的数据表格，因而会有效率的问题。

#### reference

https://www.cnblogs.com/laonicc/p/13340260.html